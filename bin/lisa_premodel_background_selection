#!/usr/bin/env python
from sklearn.model_selection import RandomizedSearchCV
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import make_scorer, average_precision_score, roc_auc_score
from scipy.stats import uniform
import h5py
import fire
import os
import numpy as np
import fire
from lisa.data import EpigenomeData
from lisa.utils import binarize_gene_set
from lisa.model import Logit
from sklearn.preprocessing import StandardScaler
import pandas as pd
import numpy as np

def get_background(species, epigenomes, gene_set, prefix, random):
    """ get background information by using regression of all input data of epigenome types
    cluster center to get the predicted RP and get the 1000 nearest neighbors
    """
    rank_dict = {}
    for e in epigenomes:
        epigenome = EpigenomeData(species, e)
        feature = epigenome.get_cluster_median
        refseq = feature.index.map(lambda x: x.split(':')[-2].upper())
        symbol = feature.index.map(lambda x: x.split(':')[-1].upper())

        gene_vec = binarize_gene_set(gene_set, refseq, symbol)
        feature.loc[:, 'Y'] = gene_vec
        feature.loc[:, 'symbols'] = symbol
        feature_symbols = feature.drop_duplicates(subset='symbols', keep='first', inplace=False)
        feature_symbols = feature_symbols.drop('symbols', axis=1, inplace=False)
        np.savetxt('%s.foreground_gene' % prefix,
                   feature_symbols.index[feature_symbols.Y==1].values, fmt="%s")
        feature_symbols_x = feature_symbols.iloc[:, :(feature_symbols.shape[1]-1)]
        feature_symbols_y = feature_symbols.Y
        scale = StandardScaler(with_std=False)
        feature_symbols_x = pd.DataFrame(scale.fit_transform(feature_symbols_x),
                                         columns=feature_symbols_x.columns,
                                         index=feature_symbols_x.index)
        fold = KFold(n_splits=3, shuffle=True, random_state=777)
        np.random.RandomState(777)
        parameters = {'clf__C': np.random.uniform(1e3, 1e8, 5)}
        logit = LogisticRegression(penalty='l1', tol=0.01, dual=False, random_state=999)
        lisa_expression_gs = GridSearchCV(Pipeline([('clf', logit)]),
                                          parameters, cv=fold, n_jobs=1,
                                          scoring=make_scorer(roc_auc_score))
        lisa_expression_gs.fit(feature_symbols_x, feature_symbols_y)

        prediction = lisa_expression_gs.predict_log_proba(feature_symbols_x)[:, 1]
        prauc = average_precision_score(feature_symbols_y, prediction)
        auc = roc_auc_score(feature_symbols_y, prediction)
        coefs = lisa_expression_gs.best_estimator_.named_steps['clf'].coef_[0]
        best_params = lisa_expression_gs.best_params_.get('clf__C', None)
        with open('%s.premodel_records.txt' % prefix, 'w') as cluster_regf:
            cluster_regf.write("%s\t%s\t%s\n" % (prauc, auc, best_params))
            cluster_regf.write('\t'.join(list(map(str, coefs))))

        rank_dict[e] = prediction

    rank_df = pd.DataFrame(rank_dict, index=feature_symbols_x.index)
    rank_df = rank_df.rank(axis=0, ascending=False)
    prediction_control = rank_df.ix[feature_symbols_y==0, :]
    prediction_diff = rank_df.ix[feature_symbols_y==1, :]

    # control gene number matching one differential gene
    diff_gene = feature_symbols.index[feature_symbols.Y == 1]
    if len(diff_gene) <= 3000:
        control_gene_per_diff = 3000 // prediction_diff.shape[0]
    else:
        raise Exception('more genes than 3000...')
    # |rank_j K4me3 - rank_i K4me3| + | rank_j K27ac - rank_i K27ac | +  | rank_j GC - rank_i GC |
    np.random.RandomState(999)

    if not random:
        background_genes = set()
        for fore_gene in diff_gene:
            dist = prediction_control.sub(prediction_diff.loc[fore_gene], axis=1) \
                                     .abs() \
                                     .sum(axis=1)
            dist.sort_values(axis=0, ascending=True, inplace=True)
            background_genes = background_genes.union(dist.index[:control_gene_per_diff])
    else:
        #background_genes = np.random.choice(feature_symbols.index[feature_symbols.Y == 0], size=2000, replace=False)
        background_genes = np.random.choice(feature_symbols.index[feature_symbols.Y == 0], size=3000, replace=False)

    background_genes = np.array(list(background_genes))
    print(background_genes)
    print(len(background_genes))

    np.savetxt('%s.background_gene.2000' % prefix,
               background_genes, fmt="%s")

    np.savetxt('%s.background_gene.300' % prefix,
               np.random.choice(background_genes, size=300, replace=False), fmt="%s")

if __name__ == '__main__':
    fire.Fire(get_background)
